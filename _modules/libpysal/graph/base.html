<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>libpysal.graph.base &#8212; libpysal v4.9.2 Manual</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bootstrap-sphinx.css?v=9afac83c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pysal-styles.css?v=38b0ce36" />
    <script src="../../../_static/documentation_options.js?v=e919e384"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="icon" href="../../../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          libpysal</a>
        <span class="navbar-text navbar-version pull-left"><b>4.9.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../installation.html">Installation</a></li>
                <li><a href="../../../tutorial.html">Tutorial</a></li>
                <li><a href="../../../api.html">API</a></li>
                <li><a href="../../../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#installing-released-version">Installing released version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#installing-development-version">Installing development version</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial.html#spatial-weights">Spatial Weights</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial.html#example-datasets">Example Datasets</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#spatial-weights">Spatial Weights</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#cg-computational-geometry">cg: Computational Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#io">io</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#examples">examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#experimental">Experimental</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#graph">graph</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for libpysal.graph.base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cached_property</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>

<span class="kn">from</span> <span class="nn">libpysal.weights</span> <span class="kn">import</span> <span class="n">W</span>

<span class="kn">from</span> <span class="nn">._contiguity</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_block_contiguity</span><span class="p">,</span>
    <span class="n">_fuzzy_contiguity</span><span class="p">,</span>
    <span class="n">_queen</span><span class="p">,</span>
    <span class="n">_rook</span><span class="p">,</span>
    <span class="n">_vertex_set_intersection</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">._kernel</span> <span class="kn">import</span> <span class="n">_distance_band</span><span class="p">,</span> <span class="n">_kernel</span>
<span class="kn">from</span> <span class="nn">._parquet</span> <span class="kn">import</span> <span class="n">_read_parquet</span><span class="p">,</span> <span class="n">_to_parquet</span>
<span class="kn">from</span> <span class="nn">._plotting</span> <span class="kn">import</span> <span class="n">_explore_graph</span><span class="p">,</span> <span class="n">_plot</span>
<span class="kn">from</span> <span class="nn">._set_ops</span> <span class="kn">import</span> <span class="n">SetOpsMixin</span>
<span class="kn">from</span> <span class="nn">._spatial_lag</span> <span class="kn">import</span> <span class="n">_lag_spatial</span>
<span class="kn">from</span> <span class="nn">._triangulation</span> <span class="kn">import</span> <span class="n">_delaunay</span><span class="p">,</span> <span class="n">_gabriel</span><span class="p">,</span> <span class="n">_relative_neighborhood</span><span class="p">,</span> <span class="n">_voronoi</span>
<span class="kn">from</span> <span class="nn">._utils</span> <span class="kn">import</span> <span class="n">_evaluate_index</span><span class="p">,</span> <span class="n">_neighbor_dict_to_edges</span><span class="p">,</span> <span class="n">_sparse_to_arrays</span>

<span class="n">ALLOWED_TRANSFORMATIONS</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;V&quot;</span><span class="p">)</span>

<span class="c1"># listed alphabetically</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;&quot;</span>
<span class="s2">Martin Fleischmann (martin@martinfleischmann.net)</span>
<span class="s2">Eli Knaap (ek@knaaptime.com)</span>
<span class="s2">Serge Rey (sjsrey@gmail.com)</span>
<span class="s2">Levi John Wolf (levi.john.wolf@gmail.com)</span>
<span class="s2">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="Graph">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph">[docs]</a>
<span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">SetOpsMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Graph class encoding spatial weights matrices</span>

<span class="sd">    The :class:`Graph` is currently experimental</span>
<span class="sd">    and its API is incomplete and unstable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Graph.__init__">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjacency</span><span class="p">,</span> <span class="n">transformation</span><span class="o">=</span><span class="s2">&quot;O&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Weights base class based on adjacency list</span>

<span class="sd">        It is recommenced to use one of the ``from_*`` or ``build_*`` constructors</span>
<span class="sd">        rather than invoking ``__init__`` directly.</span>

<span class="sd">        Each observation needs to be present in the focal,</span>
<span class="sd">        at least as a self-loop with a weight 0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adjacency : pandas.Series</span>
<span class="sd">            A MultiIndexed pandas.Series with ``&quot;focal&quot;`` and ``&quot;neigbor&quot;`` levels</span>
<span class="sd">            encoding adjacency, and values encoding weights. By convention,</span>
<span class="sd">            isolates are encoded as self-loops with a weight 0.</span>
<span class="sd">        transformation : str, default &quot;O&quot;</span>
<span class="sd">            weights transformation used to produce the table.</span>

<span class="sd">            - **O** -- Original</span>
<span class="sd">            - **B** -- Binary</span>
<span class="sd">            - **R** -- Row-standardization (global sum :math:`=n`)</span>
<span class="sd">            - **D** -- Double-standardization (global sum :math:`=1`)</span>
<span class="sd">            - **V** -- Variance stabilizing</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adjacency</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The adjacency table needs to be a pandas.Series. </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">adjacency</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The index of the adjacency table needs to be a MultiIndex named &quot;</span>
                <span class="s2">&quot;[&#39;focal&#39;, &#39;neighbor&#39;].&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The adjacency needs to be named &#39;weight&#39;. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">adjacency</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; was given instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">adjacency</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The &#39;weight&#39; needs to be of a numeric dtype. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">adjacency</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&#39; dtype was given instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The adjacency table cannot contain missing values.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transformation</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ALLOWED_TRANSFORMATIONS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;transformation&#39; needs to be one of </span><span class="si">{</span><span class="n">ALLOWED_TRANSFORMATIONS</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">transformation</span><span class="si">}</span><span class="s2">&#39; was given instead.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># adjacency always ordered i--&gt;j on both levels</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
        <span class="n">adjacency</span> <span class="o">=</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span> <span class="o">=</span> <span class="n">adjacency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span> <span class="o">=</span> <span class="n">transformation</span></div>


    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Easy lookup based on focal index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : hashable</span>
<span class="sd">            hashable represting an index value</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            subset of the adjacency table for `item`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">isolates</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="p">[],</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span><span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

<div class="viewcode-block" id="Graph.copy">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a copy of this Graph&#39;s adjacency table and transformation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, optional</span>
<span class="sd">            Make a deep copy of the adjacency table, by default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph as a copy of the original</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Graph</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">),</span> <span class="n">transformation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span>
        <span class="p">)</span></div>


    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of the adjacency list</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            Underlying adjacency list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="Graph.from_W">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_W">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_W</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c1"># noqa N802</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an experimental Graph from libpysal.weights.W object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        w : libpysal.weights.W</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph from W</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_weights_dict</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="p">))</span></div>


<div class="viewcode-block" id="Graph.to_W">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.to_W">[docs]</a>
    <span class="k">def</span> <span class="nf">to_W</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa N802</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert Graph to a libpysal.weights.W object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        libpysal.weights.W</span>
<span class="sd">            representation of graph as a weights.W object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;focal&quot;</span><span class="p">),</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">group</span><span class="p">[</span>
                        <span class="o">~</span><span class="p">((</span><span class="n">group</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">group</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">neighbor</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">neighbors</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">neighbors</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">group</span><span class="p">[</span>
                        <span class="o">~</span><span class="p">((</span><span class="n">group</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">group</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">weight</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">weights</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">weights</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">W</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="n">weights</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="n">id_order</span><span class="o">=</span><span class="n">labels</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span></div>


<div class="viewcode-block" id="Graph.from_adjacency">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_adjacency">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_adjacency</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">adjacency</span><span class="p">,</span> <span class="n">focal_col</span><span class="o">=</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span> <span class="n">neighbor_col</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span><span class="p">,</span> <span class="n">weight_col</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Graph from a pandas DataFrame formatted as an adjacency list</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adjacency : pandas.DataFrame</span>
<span class="sd">            a dataframe formatted as an ajacency list. Should have columns</span>
<span class="sd">            &quot;focal&quot;, &quot;neighbor&quot;, and &quot;weight&quot;, or columns that can be mapped</span>
<span class="sd">            to these (e.g. origin, destination, cost)</span>
<span class="sd">        focal : str, optional</span>
<span class="sd">            name of column holding focal/origin index, by default &#39;focal&#39;</span>
<span class="sd">        neighbor : str, optional</span>
<span class="sd">            name of column holding neighbor/destination index, by default &#39;neighbor&#39;</span>
<span class="sd">        weight : str, optional</span>
<span class="sd">            name of column holding weight values, by default &#39;weight&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="p">[</span><span class="n">focal_col</span><span class="p">,</span> <span class="n">neighbor_col</span><span class="p">,</span> <span class="n">weight_col</span><span class="p">],</span>
                <span class="p">[</span><span class="s2">&quot;focal_col&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor_col&quot;</span><span class="p">,</span> <span class="s2">&quot;weight_col&quot;</span><span class="p">],</span>
                <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s1">&quot; was given for `</span><span class="si">{</span><span class="n">cols</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="si">}</span><span class="s1">`, but the &#39;</span>
                <span class="sa">f</span><span class="s2">&quot;columns available in `adjacency` are:  </span><span class="si">{</span><span class="n">adjacency</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
            <span class="n">adjacency</span><span class="p">[</span><span class="n">focal_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">adjacency</span><span class="p">[</span><span class="n">neighbor_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">adjacency</span><span class="p">[</span><span class="n">weight_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.from_sparse">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_sparse">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_sparse</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a ``scipy.sparse`` array to a PySAL ``Graph`` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sparse : scipy.sparse array</span>
<span class="sd">            sparse representation of a graph</span>
<span class="sd">        ids : list-like, default None</span>
<span class="sd">            list-like of ids for geometries that is mappable to</span>
<span class="sd">            positions from sparse. If None, the positions are used as labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph based on sparse</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">_sparse_to_arrays</span><span class="p">(</span><span class="n">sparse</span><span class="p">,</span> <span class="n">ids</span><span class="p">))</span></div>


<div class="viewcode-block" id="Graph.from_arrays">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_arrays">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_arrays</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">focal_ids</span><span class="p">,</span> <span class="n">neighbor_ids</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from arrays of indices and weights of the same length</span>

<span class="sd">        The arrays needs to be sorted in a way ensuring that focal_ids.unique() is</span>
<span class="sd">        equal to the index of original observations from which the Graph is being built</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        focal_index : array-like</span>
<span class="sd">            focal indices</span>
<span class="sd">        neighbor_index : array-like</span>
<span class="sd">            neighbor indices</span>
<span class="sd">        weight : array-like</span>
<span class="sd">            weights</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph based on arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">w</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">weight</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">focal_ids</span><span class="p">,</span> <span class="n">neighbor_ids</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">]</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">w</span></div>


<div class="viewcode-block" id="Graph.from_weights_dict">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_weights_dict">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_weights_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">weights_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from a dict of dicts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weights_dict : dictionary of dictionaries</span>
<span class="sd">            weights dictionary with the ``{focal: {neighbor: weight}}`` structure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph based on weights dictionary of dictionaries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">weights_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">weights_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dicts</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.from_dicts">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_dicts">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dicts</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from dictionaries of neighbors and weights</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        neighbors : dict</span>
<span class="sd">            dictionary of neighbors with the ``{focal: [neighbor1, neighbor2]}``</span>
<span class="sd">            structure</span>
<span class="sd">        weights : dict, optional</span>
<span class="sd">            dictionary of neighbors with the ``{focal: [weight1, weight2]}``</span>
<span class="sd">            structure. If None, assumes binary weights.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph based on dictionaries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_neighbor_dict_to_edges</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_contiguity">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_contiguity">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_contiguity</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">rook</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">by_perimeter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from geometry based on contiguity</span>

<span class="sd">        Contiguity builder assumes that all geometries are forming a coverage, i.e.</span>
<span class="sd">        a non-overlapping mesh and neighbouring geometries share only points or</span>
<span class="sd">        segments of their exterior boundaries. In practice, ``build_contiguity`` is</span>
<span class="sd">        capable of creating a Graph of partially overlapping geometries when</span>
<span class="sd">        ``strict=False, by_perimeter=False``, but that would not strictly follow the</span>
<span class="sd">        definition of queen or rook contiguity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry : array-like of shapely.Geometry objects</span>
<span class="sd">            Could be geopandas.GeoSeries or geopandas.GeoDataFrame, in which case the</span>
<span class="sd">            resulting Graph is indexed by the original index. If an array of</span>
<span class="sd">            shapely.Geometry objects is passed, Graph will assume a RangeIndex.</span>
<span class="sd">        rook : bool, optional</span>
<span class="sd">            Contiguity method. If True, two geometries are considered neighbours if</span>
<span class="sd">            they share at least one edge. If False, two geometries are considered</span>
<span class="sd">            neighbours if they share at least one vertex. By default True</span>
<span class="sd">        by_perimeter : bool, optional</span>
<span class="sd">            If True, ``weight`` represents the length of the shared boundary between</span>
<span class="sd">            adjacent units, by default False. For row-standardized version of perimeter</span>
<span class="sd">            weights, use</span>
<span class="sd">            ``Graph.build_contiguity(gdf, by_perimeter=True).transform(&quot;r&quot;)``.</span>
<span class="sd">        strict : bool, optional</span>
<span class="sd">            Use the strict topological method. If False, the contiguity is determined</span>
<span class="sd">            based on shared coordinates or coordinate sequences representing edges.</span>
<span class="sd">            This assumes geometry coverage that is topologically correct. This method</span>
<span class="sd">            is faster but can miss some relations. If True, the contiguity is</span>
<span class="sd">            determined based on geometric relations that do not require precise</span>
<span class="sd">            topology. This method is slower but will result in correct contiguity</span>
<span class="sd">            even if the topology of geometries is not optimal. By default False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding contiguity weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">):</span>
            <span class="c1"># potentially cast GeoDataFrame to GeoSeries</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">geometry</span>

        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="c1"># use shapely-based constructors</span>
            <span class="k">if</span> <span class="n">rook</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">_rook</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">by_perimeter</span><span class="o">=</span><span class="n">by_perimeter</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                <span class="o">*</span><span class="n">_queen</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">by_perimeter</span><span class="o">=</span><span class="n">by_perimeter</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># use vertex-based constructor</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
            <span class="o">*</span><span class="n">_vertex_set_intersection</span><span class="p">(</span>
                <span class="n">geometry</span><span class="p">,</span> <span class="n">rook</span><span class="o">=</span><span class="n">rook</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">by_perimeter</span><span class="o">=</span><span class="n">by_perimeter</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_kernel">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_kernel">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_kernel</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
        <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">coincident</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from geometry data based on a kernel function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray, geopandas.GeoSeries, geopandas.GeoDataFrame</span>
<span class="sd">            geometries over which to compute a kernel. If a geopandas object with Point</span>
<span class="sd">            geoemtry is provided, the .geometry attribute is used. If a numpy.ndarray</span>
<span class="sd">            with shapely geoemtry is used, then the coordinates are extracted and used.</span>
<span class="sd">            If a numpy.ndarray of a shape (2,n) is used, it is assumed to contain x, y</span>
<span class="sd">            coordinates. If metric=&quot;precomputed&quot;, data is assumed to contain a</span>
<span class="sd">            precomputed distance metric.</span>
<span class="sd">        kernel : string or callable (default: &#39;gaussian&#39;)</span>
<span class="sd">            kernel function to apply over the distance matrix computed by `metric`.</span>
<span class="sd">            The following kernels are supported:</span>

<span class="sd">            - ``&quot;triangular&quot;``:</span>
<span class="sd">            - ``&quot;parabolic&quot;``:</span>
<span class="sd">            - ``&quot;gaussian&quot;``:</span>
<span class="sd">            - ``&quot;bisquare&quot;``:</span>
<span class="sd">            - ``&quot;cosine&quot;``:</span>
<span class="sd">            - ``&#39;boxcar&#39;``/discrete: all distances less than `bandwidth` are 1, and all</span>
<span class="sd">              other distances are 0</span>
<span class="sd">            - ``&quot;identity&quot;``/None : do nothing, weight similarity based on raw distance</span>
<span class="sd">            - ``callable`` : a user-defined function that takes the distance vector and</span>
<span class="sd">              the bandwidth and returns the kernel: kernel(distances, bandwidth)</span>

<span class="sd">        k : int (default: None)</span>
<span class="sd">            number of nearest neighbors used to truncate the kernel. This is assumed</span>
<span class="sd">            to be constant across samples. If None, no truncation is conduted.</span>
<span class="sd">        bandwidth : float (default: None)</span>
<span class="sd">            distance to use in the kernel computation. Should be on the same scale as</span>
<span class="sd">            the input coordinates.</span>
<span class="sd">        metric : string or callable (default: &#39;euclidean&#39;)</span>
<span class="sd">            distance function to apply over the input coordinates. Supported options</span>
<span class="sd">            depend on whether or not scikit-learn is installed. If so, then any</span>
<span class="sd">            distance function supported by scikit-learn is supported here. Otherwise,</span>
<span class="sd">            only euclidean, minkowski, and manhattan/cityblock distances are admitted.</span>
<span class="sd">        p : int (default: 2)</span>
<span class="sd">            parameter for minkowski metric, ignored if metric != &quot;minkowski&quot;.</span>
<span class="sd">        coincident: str, optional (default &quot;raise&quot;)</span>
<span class="sd">            Method for handling coincident points when ``k`` is not None. Options are</span>
<span class="sd">            ``&#39;raise&#39;`` (raising an exception when coincident points are present),</span>
<span class="sd">            ``&#39;jitter&#39;`` (randomly displace coincident points to produce uniqueness), &amp;</span>
<span class="sd">            ``&#39;clique&#39;`` (induce fully-connected sub cliques for coincident points).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding kernel weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_kernel</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
            <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
            <span class="n">coincident</span><span class="o">=</span><span class="n">coincident</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_knn">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_knn">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_knn</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">coincident</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from geometry data based on k-nearest neighbors search</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray, geopandas.GeoSeries, geopandas.GeoDataFrame</span>
<span class="sd">            geometries over which to compute a kernel. If a geopandas object with Point</span>
<span class="sd">            geoemtry is provided, the .geometry attribute is used. If a numpy.ndarray</span>
<span class="sd">            with shapely geoemtry is used, then the coordinates are extracted and used.</span>
<span class="sd">            If a numpy.ndarray of a shape (2,n) is used, it is assumed to contain x, y</span>
<span class="sd">            coordinates.</span>
<span class="sd">        k : int</span>
<span class="sd">            number of nearest neighbors.</span>
<span class="sd">        metric : string or callable (default: &#39;euclidean&#39;)</span>
<span class="sd">            distance function to apply over the input coordinates. Supported options</span>
<span class="sd">            depend on whether or not scikit-learn is installed. If so, then any</span>
<span class="sd">            distance function supported by scikit-learn is supported here. Otherwise,</span>
<span class="sd">            only euclidean, minkowski, and manhattan/cityblock distances are admitted.</span>
<span class="sd">        p : int (default: 2)</span>
<span class="sd">            parameter for minkowski metric, ignored if metric != &quot;minkowski&quot;.</span>
<span class="sd">        coincident: str, optional (default &quot;raise&quot;)</span>
<span class="sd">            Method for handling coincident points. Options include</span>
<span class="sd">            ``&#39;raise&#39;`` (raising an exception when coincident points are present),</span>
<span class="sd">            ``&#39;jitter&#39;`` (randomly displace coincident points to produce uniqueness), &amp;</span>
<span class="sd">            ``&#39;clique&#39;`` (induce fully-connected sub cliques for coincident points).</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding KNN weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_kernel</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">bandwidth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
            <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;boxcar&quot;</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
            <span class="n">coincident</span><span class="o">=</span><span class="n">coincident</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_triangulation">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_triangulation">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_triangulation</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;delaunay&quot;</span><span class="p">,</span>
        <span class="n">bandwidth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;boxcar&quot;</span><span class="p">,</span>
        <span class="n">clip</span><span class="o">=</span><span class="s2">&quot;extent&quot;</span><span class="p">,</span>
        <span class="n">rook</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">coincident</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from geometry based on triangulation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray, geopandas.GeoSeries, geopandas.GeoDataFrame</span>
<span class="sd">            geometries containing locations to compute the</span>
<span class="sd">            delaunay triangulation. If a geopandas object with Point</span>
<span class="sd">            geoemtry is provided, the .geometry attribute is used. If a numpy.ndarray</span>
<span class="sd">            with shapely geoemtry is used, then the coordinates are extracted and used.</span>
<span class="sd">            If a numpy.ndarray of a shape (2,n) is used, it is assumed to contain x, y</span>
<span class="sd">            coordinates.</span>
<span class="sd">        method : str, (default &quot;delaunay&quot;)</span>
<span class="sd">            method of extracting the weights from triangulation. Supports:</span>

<span class="sd">            - ``&quot;delaunay&quot;``</span>
<span class="sd">            - ``&quot;gabriel&quot;``</span>
<span class="sd">            - ``&quot;relative_neighborhood&quot;``</span>
<span class="sd">            - ``&quot;voronoi&quot;``</span>

<span class="sd">        bandwidth : float, optional</span>
<span class="sd">            distance to use in the kernel computation. Should be on the same scale as</span>
<span class="sd">            the input coordinates, by default numpy.inf</span>
<span class="sd">        kernel : str, optional</span>
<span class="sd">            kernel function to use in order to weight the output graph. See</span>
<span class="sd">            :meth:`Graph.build_kernel` for details. By default &quot;boxcar&quot;</span>
<span class="sd">        clip : str (default: &#39;bbox&#39;)</span>
<span class="sd">            Clipping method when ``method=&quot;voronoi&quot;``. Ignored otherwise.</span>
<span class="sd">            Default is ``&#39;extent&#39;``. Options are as follows.</span>

<span class="sd">            - ``&#39;none&#39;``/``None``: No clip is applied. Voronoi cells may be</span>
<span class="sd">              arbitrarily larger that the source map. Note that this may lead to</span>
<span class="sd">              cells that are many orders of magnitude larger in extent than the</span>
<span class="sd">              original map. Not recommended.</span>
<span class="sd">            - ``&#39;bbox&#39;``/``&#39;extent&#39;``/``&#39;bounding box&#39;``: Clip the voronoi cells to</span>
<span class="sd">              the bounding box of the input points.</span>
<span class="sd">            - ``&#39;chull``/``&#39;convex hull&#39;``: Clip the voronoi cells to the convex hull</span>
<span class="sd">              of the input points.</span>
<span class="sd">            - ``&#39;ashape&#39;``/``&#39;ahull&#39;``: Clip the voronoi cells to the tightest hull</span>
<span class="sd">              that contains all points (e.g. the smallest alphashape, using</span>
<span class="sd">              :func:`libpysal.cg.alpha_shape_auto`).</span>
<span class="sd">            - ``shapely.Polygon``: Clip to an arbitrary Polygon.</span>

<span class="sd">        rook : bool, optional</span>
<span class="sd">            Contiguity method when ``method=&quot;voronoi&quot;``. Ignored otherwise.</span>
<span class="sd">            If True, two geometries are considered neighbours if they</span>
<span class="sd">            share at least one edge. If False, two geometries are considered neighbours</span>
<span class="sd">            if they share at least one vertex. By default True</span>
<span class="sd">        coincident: str, optional (default &quot;raise&quot;)</span>
<span class="sd">            Method for handling coincident points. Options include</span>
<span class="sd">            ``&#39;raise&#39;`` (raising an exception when coincident points are present),</span>
<span class="sd">            ``&#39;jitter&#39;`` (randomly displace coincident points to produce uniqueness), &amp;</span>
<span class="sd">            ``&#39;clique&#39;`` (induce fully-connected sub cliques for coincident points).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding triangulation weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;delaunay&quot;</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_delaunay</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">coincident</span><span class="o">=</span><span class="n">coincident</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;gabriel&quot;</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_gabriel</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">coincident</span><span class="o">=</span><span class="n">coincident</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;relative_neighborhood&quot;</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_relative_neighborhood</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">coincident</span><span class="o">=</span><span class="n">coincident</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;voronoi&quot;</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_voronoi</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="n">clip</span><span class="p">,</span> <span class="n">rook</span><span class="o">=</span><span class="n">rook</span><span class="p">,</span> <span class="n">coincident</span><span class="o">=</span><span class="n">coincident</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; is not supported. Use one of [&#39;delaunay&#39;, &quot;</span>
                <span class="s2">&quot;&#39;gabriel&#39;, &#39;relative_neighborhood&#39;, &#39;voronoi&#39;].&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_distance_band">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_distance_band">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_distance_band</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from geometry based on a distance band</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray, geopandas.GeoSeries, geopandas.GeoDataFrame</span>
<span class="sd">            geometries containing locations to compute the</span>
<span class="sd">            delaunay triangulation. If a geopandas object with Point</span>
<span class="sd">            geometry is provided, the .geometry attribute is used. If a numpy.ndarray</span>
<span class="sd">            with shapely geometry is used, then the coordinates are extracted and used.</span>
<span class="sd">            If a numpy.ndarray of a shape (2,n) is used, it is assumed to contain x, y</span>
<span class="sd">            coordinates.</span>
<span class="sd">        threshold : float</span>
<span class="sd">            distance band</span>
<span class="sd">        binary : bool, optional</span>
<span class="sd">            If True :math:`w_{ij}=1` if :math:`d_{i,j}&lt;=threshold`, otherwise</span>
<span class="sd">            :math:`w_{i,j}=0`.</span>
<span class="sd">            If False :math:`wij=dij^{alpha}`, by default True.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            distance decay parameter for weight (default -1.0)</span>
<span class="sd">            if alpha is positive the weights will not decline with</span>
<span class="sd">            distance. Ignored if ``binary=True`` or ``kernel`` is not None.</span>
<span class="sd">        kernel : str, optional</span>
<span class="sd">            kernel function to use in order to weight the output graph. See</span>
<span class="sd">            :meth:`Graph.build_kernel` for details. Ignored if ``binary=True``.</span>
<span class="sd">        bandwidth : float (default: None)</span>
<span class="sd">            distance to use in the kernel computation. Should be on the same scale as</span>
<span class="sd">            the input coordinates. Ignored if ``binary=True`` or ``kernel=None``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding distance band weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">_distance_band</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_kernel</span><span class="p">(</span>
                <span class="n">dist</span><span class="p">,</span>
                <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;boxcar&quot;</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">,</span>
                <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
                <span class="n">bandwidth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">kernel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_kernel</span><span class="p">(</span>
                <span class="n">dist</span><span class="p">,</span>
                <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">,</span>
                <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
                <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_kernel</span><span class="p">(</span>
                <span class="n">dist</span><span class="p">,</span>
                <span class="n">kernel</span><span class="o">=</span><span class="k">lambda</span> <span class="n">distances</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">alpha</span><span class="p">),</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">,</span>
                <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
                <span class="n">bandwidth</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">adjacency</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;focal&quot;</span><span class="p">:</span> <span class="n">head</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">:</span> <span class="n">tail</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">weight</span><span class="p">}</span>
        <span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;focal&quot;</span><span class="p">)</span>

        <span class="c1"># drop diagonal</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="n">no_isolates</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">adjacency</span> <span class="o">=</span> <span class="n">adjacency</span><span class="p">[</span>
            <span class="o">~</span><span class="p">(</span>
                <span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">no_isolates</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">adjacency</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># set isolates to 0 - distance band should never contain self-weight</span>
        <span class="n">adjacency</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">no_isolates</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
            <span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">values</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_block_contiguity">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_block_contiguity">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_block_contiguity</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">regimes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from block contiguity (regime neighbors)</span>

<span class="sd">        Block contiguity structures are relevant when defining neighbor relations</span>
<span class="sd">        based on membership in a regime. For example, all counties belonging to</span>
<span class="sd">        the same state could be defined as neighbors, in an analysis of all</span>
<span class="sd">        counties in the US.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        regimes : list-like</span>
<span class="sd">            list-like of regimes. If pandas.Series, its index is used to encode Graph.</span>
<span class="sd">            Otherwise a default RangeIndex is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding block contiguity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">regimes</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dicts</span><span class="p">(</span><span class="n">_block_contiguity</span><span class="p">(</span><span class="n">regimes</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">))</span></div>


<div class="viewcode-block" id="Graph.build_fuzzy_contiguity">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_fuzzy_contiguity">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_fuzzy_contiguity</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">geometry</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from fuzzy contiguity</span>

<span class="sd">        Fuzzy contiguity relaxes the notion of contiguity neighbors</span>
<span class="sd">        for the case of geometry collections that violate the condition</span>
<span class="sd">        of planar enforcement. It handles three types of conditions present</span>
<span class="sd">        in such collections that would result in missing links when using</span>
<span class="sd">        the regular contiguity methods.</span>

<span class="sd">        The first are edges for nearby polygons that should be shared, but are</span>
<span class="sd">        digitized separately for the individual polygons and the resulting edges</span>
<span class="sd">        do not coincide, but instead the edges intersect. This case can also be</span>
<span class="sd">        covered by ``build_contiguty`` with the ``strict=False`` parameter.</span>

<span class="sd">        The second case is similar to the first, only the resultant edges do not</span>
<span class="sd">        intersect but are &quot;close&quot;. The optional buffering of geometry then closes the</span>
<span class="sd">        gaps between the polygons and a resulting intersection is encoded as a link.</span>

<span class="sd">        The final case arises when one polygon is &quot;inside&quot; a second polygon but is not</span>
<span class="sd">        encoded to represent a hole in the containing polygon.</span>

<span class="sd">        It is also possible to create a contiguity based on a custom spatial predicate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geoms :  array-like of shapely.Geometry objects</span>
<span class="sd">            Could be geopandas.GeoSeries or geopandas.GeoDataFrame, in which case the</span>
<span class="sd">            resulting Graph is indexed by the original index. If an array of</span>
<span class="sd">            shapely.Geometry objects is passed, Graph will assume a RangeIndex.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The percentage of the length of the minimum side of the bounding rectangle</span>
<span class="sd">            for the ``geoms`` to use in determining the buffering distance. Either</span>
<span class="sd">            ``tolerance`` or ``buffer`` may be specified but not both.</span>
<span class="sd">            By default None.</span>
<span class="sd">        buffer : float, optional</span>
<span class="sd">            Exact buffering distance in the units of ``geoms.crs``. Either</span>
<span class="sd">            ``tolerance`` or ``buffer`` may be specified but not both.</span>
<span class="sd">            By default None.</span>
<span class="sd">        predicate : str, optional</span>
<span class="sd">            The predicate to use for determination of neighbors. Default is</span>
<span class="sd">            &#39;intersects&#39;. If None is passed, neighbours are determined based</span>
<span class="sd">            on the intersection of bounding boxes. See the documentation of</span>
<span class="sd">            ``geopandas.GeoSeries.sindex.query`` for allowed predicates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding fuzzy contiguity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>

        <span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_fuzzy_contiguity</span><span class="p">(</span>
            <span class="n">geometry</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="n">predicate</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span></div>


    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get neighbors dictionary</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        It is recommended to work directly with :meth:`Graph.adjacency` rather than</span>
<span class="sd">        using the :meth:`Graph.neighbors`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            dict of tuples representing neighbors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">group</span><span class="p">[</span>
                        <span class="o">~</span><span class="p">((</span><span class="n">group</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">group</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">neighbor</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get weights dictionary</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        It is recommended to work directly with :meth:`Graph.adjacency` rather than</span>
<span class="sd">        using the :meth:`Graph.weights`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            dict of tuples representing weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">group</span><span class="p">[</span>
                        <span class="o">~</span><span class="p">((</span><span class="n">group</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">group</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">weight</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a scipy.sparse array (COO)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scipy.sparse.COO</span>
<span class="sd">            sparse representation of the adjacency</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pivot to COO sparse matrix and cast to array</span>
        <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;Sparse[float]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">to_coo</span><span class="p">(</span><span class="n">sort_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Graph.transform">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformation</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transformation of weights</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transformation : str</span>
<span class="sd">            Transformation method. The following are</span>
<span class="sd">            valid transformations.</span>

<span class="sd">            - **B** -- Binary</span>
<span class="sd">            - **R** -- Row-standardization (global sum :math:`=n`)</span>
<span class="sd">            - **D** -- Double-standardization (global sum :math:`=1`)</span>
<span class="sd">            - **V** -- Variance stabilizing</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            transformed weights</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Value error for unsupported transformation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transformation</span> <span class="o">=</span> <span class="n">transformation</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span> <span class="o">==</span> <span class="n">transformation</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">transformation</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="n">standardized</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">))</span>
                <span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>  <span class="c1"># isolate comes as NaN -&gt; 0</span>

        <span class="k">elif</span> <span class="n">transformation</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span><span class="p">:</span>
            <span class="n">standardized</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">values</span>

        <span class="k">elif</span> <span class="n">transformation</span> <span class="o">==</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span>
            <span class="n">standardized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">transformation</span> <span class="o">==</span> <span class="s2">&quot;V&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="n">group</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">group</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="n">n_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">standardized</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">n_q</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># isolate comes as NaN -&gt; 0</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Transformation &#39;</span><span class="si">{</span><span class="n">transformation</span><span class="si">}</span><span class="s2">&#39; is not supported. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Use one of </span><span class="si">{</span><span class="n">ALLOWED_TRANSFORMATIONS</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">standardized_adjacency</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">standardized</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Graph</span><span class="p">(</span><span class="n">standardized_adjacency</span><span class="p">,</span> <span class="n">transformation</span><span class="p">)</span></div>


    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;helper for n_components and component_labels&quot;&quot;&quot;</span>
        <span class="c1"># TODO: remove casting to matrix once scipy supports arrays here</span>
        <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">))</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number of connected components</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of components</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">component_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get component labels per observation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            Array of component labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_components</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;component labels&quot;</span>
        <span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">cardinalities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of neighbors for each observation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            Series with a number of neighbors per each observation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cardinalities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">cardinalities</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;cardinalities&quot;</span>
        <span class="k">return</span> <span class="n">cardinalities</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">isolates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Index of observations with no neighbors</span>

<span class="sd">        Isolates are encoded as a self-loop with</span>
<span class="sd">        the weight == 0 in the adjacency table.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Index</span>
<span class="sd">            Index with a subset of observations that do not have any neighbor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nulls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># since not all zeros are necessarily isolates, do the focal == neighbor check</span>
        <span class="k">return</span> <span class="n">nulls</span><span class="p">[</span><span class="n">nulls</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">nulls</span><span class="o">.</span><span class="n">neighbor</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">unique_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unique IDs used in the Graph&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;focal&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of observations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">n_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of observations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">n_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of observations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">isolates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">pct_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Percentage of nonzero weights.&quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">nnz</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of nonzero weights.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isolates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<div class="viewcode-block" id="Graph.asymmetry">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.asymmetry">[docs]</a>
    <span class="k">def</span> <span class="nf">asymmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intrinsic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Asymmetry check.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        intrinsic : bool, optional</span>
<span class="sd">            Default is ``True``. Intrinsic symmetry is defined as:</span>

<span class="sd">            .. math::</span>

<span class="sd">                w_{i,j} == w_{j,i}</span>

<span class="sd">            If ``intrinsic`` is ``False`` symmetry is defined as:</span>

<span class="sd">            .. math::</span>

<span class="sd">                i \in N_j \ \&amp; \ j \in N_i</span>

<span class="sd">            where :math:`N_j` is the set of neighbors for :math:`j`,</span>
<span class="sd">            e.g., ``True`` requires equality of the weight to consider</span>
<span class="sd">            two links equal, ``False`` requires only a presence of a link</span>
<span class="sd">            with a non-zero weight.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            A ``Series`` of ``(i,j)`` pairs of asymmetries sorted</span>
<span class="sd">            ascending by the focal observation (index value),</span>
<span class="sd">            where ``i`` is the focal and ``j`` is the neighbor.</span>
<span class="sd">            An empty ``Series`` is returned if no asymmetries are found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">intrinsic</span><span class="p">:</span>
            <span class="n">wd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
            <span class="n">wd</span> <span class="o">=</span> <span class="n">transformed</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">-</span> <span class="n">transformed</span><span class="o">.</span><span class="n">sparse</span>

        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;focal&quot;</span><span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i2id</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">focal</span><span class="p">,</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
            <span class="n">focal</span> <span class="o">=</span> <span class="n">focal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">])</span>
            <span class="n">neighbor</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i2id</span><span class="p">:</span>
                <span class="n">focal</span><span class="p">[</span><span class="n">focal</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">neighbor</span><span class="p">[</span><span class="n">neighbor</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ijs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">neighbor</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">focal</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;focal&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">ijs</span></div>


<div class="viewcode-block" id="Graph.higher_order">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.higher_order">[docs]</a>
    <span class="k">def</span> <span class="nf">higher_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">shortest_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">diagonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lower_order</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contiguity weights object of order :math:`k`.</span>

<span class="sd">        Proper higher order neighbors are returned such that :math:`i` and :math:`j`</span>
<span class="sd">        are :math:`k`-order neighbors if the shortest path from :math:`i-j` is of</span>
<span class="sd">        length :math:`k`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int, optional</span>
<span class="sd">            Order of contiguity. By default 2.</span>
<span class="sd">        shortest_path : bool, optional</span>
<span class="sd">            If True, :math:`i,j` and :math:`k`-order neighbors if the shortest</span>
<span class="sd">            path for :math:`i,j` is :math:`k`. If False, :math:`i,j` are</span>
<span class="sd">            `k`-order neighbors if there is a path from :math:`i,j` of length</span>
<span class="sd">            :math:`k`. By default True.</span>
<span class="sd">        diagonal : bool, optional</span>
<span class="sd">            If True, keep :math:`k`-order (:math:`i,j`) joins when :math:`i==j`.</span>
<span class="sd">            If False, remove :math:`k`-order (:math:`i,j`) joins when</span>
<span class="sd">            :math:`i==j`. By default False.</span>
<span class="sd">        lower_order : bool, optional</span>
<span class="sd">            If True, include lower order contiguities. If False return only weights of</span>
<span class="sd">            order :math:`k`. By default False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            higher order weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: remove casting to matrix once scipy implements matrix_power on array.</span>
        <span class="c1"># [https://github.com/scipy/scipy/pull/18544]</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">sparse</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lower_order</span><span class="p">:</span>
            <span class="n">wk</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sp</span><span class="o">**</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">shortest_path</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wk</span> <span class="o">=</span> <span class="n">sp</span><span class="o">**</span><span class="n">k</span>

        <span class="n">rk</span><span class="p">,</span> <span class="n">ck</span> <span class="o">=</span> <span class="n">wk</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">sk</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rk</span><span class="p">,</span> <span class="n">ck</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">shortest_path</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="n">wj</span> <span class="o">=</span> <span class="n">sp</span><span class="o">**</span><span class="n">j</span>
                <span class="n">rj</span><span class="p">,</span> <span class="n">cj</span> <span class="o">=</span> <span class="n">wj</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                <span class="n">sj</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rj</span><span class="p">,</span> <span class="n">cj</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">sk</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">sj</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diagonal</span><span class="p">:</span>
            <span class="n">sk</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sk</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">Graph</span><span class="o">.</span><span class="n">from_sparse</span><span class="p">(</span>
            <span class="n">sparse</span><span class="o">.</span><span class="n">coo_array</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
                    <span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sk</span><span class="p">],</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sk</span><span class="p">]),</span>
                <span class="p">),</span>
                <span class="n">shape</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">ids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.lag">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.lag">[docs]</a>
    <span class="k">def</span> <span class="nf">lag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spatial lag operator</span>

<span class="sd">        If weights are row standardized, returns the mean of each</span>
<span class="sd">        observation&#39;s neighbors; if not, returns the weighted sum</span>
<span class="sd">        of each observation&#39;s neighbors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : array-like</span>
<span class="sd">            array-like (N,) shape where N is equal to number of observations in self.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of numeric values for the spatial lag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_lag_spatial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.to_parquet">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.to_parquet">[docs]</a>
    <span class="k">def</span> <span class="nf">to_parquet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save Graph to a Apache Parquet</span>

<span class="sd">        Graph is serialized to the Apache Parquet using the underlying adjacency</span>
<span class="sd">        object stored as a Parquet table and custom metadata containing transformation.</span>

<span class="sd">        Requires pyarrow package.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str | pyarrow.NativeFile</span>
<span class="sd">            path or any stream supported by pyarrow</span>
<span class="sd">        **kwargs</span>
<span class="sd">            additional keyword arguments passed to pyarrow.parquet.write_table</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        read_parquet</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_to_parquet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.to_networkx">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.to_networkx">[docs]</a>
    <span class="k">def</span> <span class="nf">to_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert Graph to a ``networkx`` graph.</span>

<span class="sd">        If Graph is symmetric, returns ``nx.Graph``, otherwise returns a ``nx.DiGraph``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        networkx.Graph | networkx.DiGraph</span>
<span class="sd">            Representation of libpysal Graph as networkx graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;NetworkX is required.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

        <span class="n">graph_type</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asymmetry</span><span class="p">()</span><span class="o">.</span><span class="n">empty</span> <span class="k">else</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span>

        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(),</span>
            <span class="n">source</span><span class="o">=</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span>
            <span class="n">target</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span><span class="p">,</span>
            <span class="n">edge_attr</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>
            <span class="n">create_using</span><span class="o">=</span><span class="n">graph_type</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.plot">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gdf</span><span class="p">,</span>
        <span class="n">focal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
        <span class="n">edge_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">focal_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">limit_extent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot edges and nodes of the Graph</span>

<span class="sd">        Creates a ``maptlotlib`` plot based on the topology stored in the</span>
<span class="sd">        Graph and spatial location defined in ``gdf``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gdf : geopandas.GeoDataFrame</span>
<span class="sd">            Geometries indexed using the same index as Graph. Geometry types other than</span>
<span class="sd">            points are converted to centroids encoding start and end point of Graph</span>
<span class="sd">            edges.</span>
<span class="sd">        focal : hashable | array-like[hashable] | None, optional</span>
<span class="sd">            ID or an array-like of IDs of focal geometries whose weights shall be</span>
<span class="sd">            plotted. If None, all weights from all focal geometries are plotted.</span>
<span class="sd">            By default None</span>
<span class="sd">        nodes : bool, optional</span>
<span class="sd">            Plot nodes as points, by default True</span>
<span class="sd">        color : str, optional</span>
<span class="sd">            The color of all objects, by default &quot;k&quot;</span>
<span class="sd">        edge_kws : dict, optional</span>
<span class="sd">            Keyword arguments dictionary to send to ``LineCollection``,</span>
<span class="sd">            which provides fine-grained control over the aesthetics</span>
<span class="sd">            of the edges in the plot. By default None</span>
<span class="sd">        node_kws : dict, optional</span>
<span class="sd">            Keyword arguments dictionary to send to ``ax.scatter``,</span>
<span class="sd">            which provides fine-grained control over the aesthetics</span>
<span class="sd">            of the nodes in the plot. By default None</span>
<span class="sd">        focal_kws : dict, optional</span>
<span class="sd">            Keyword arguments dictionary to send to ``ax.scatter``,</span>
<span class="sd">            which provides fine-grained control over the aesthetics</span>
<span class="sd">            of the focal nodes in the plot on top of generic ``node_kws``.</span>
<span class="sd">            Values of ``node_kws`` are updated from ``focal_kws``.</span>
<span class="sd">            Ignored if ``focal=None``. By default None</span>
<span class="sd">        ax : matplotlib.axes.Axes, optional</span>
<span class="sd">            Axis on which to plot the weights. If None, a new figure and axis are</span>
<span class="sd">            created. By default None</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            figsize used to create a new axis. By default None</span>
<span class="sd">        limit_extent : bool, optional</span>
<span class="sd">            limit the extent of the axis to the extent of the plotted graph, by default</span>
<span class="sd">            False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.axes.Axes</span>
<span class="sd">            Axis with the resulting plot</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you&#39;d like to overlay the actual geometries from the</span>
<span class="sd">        ``geopandas.GeoDataFrame``, create an axis by plotting the ``GeoDataFrame``</span>
<span class="sd">        and plot the Graph on top.</span>

<span class="sd">            ax = gdf.plot()</span>
<span class="sd">            gdf_graph.plot(gdf, ax=ax)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">gdf</span><span class="p">,</span>
            <span class="n">focal</span><span class="o">=</span><span class="n">focal</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">node_kws</span><span class="o">=</span><span class="n">node_kws</span><span class="p">,</span>
            <span class="n">edge_kws</span><span class="o">=</span><span class="n">edge_kws</span><span class="p">,</span>
            <span class="n">focal_kws</span><span class="o">=</span><span class="n">focal_kws</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
            <span class="n">limit_extent</span><span class="o">=</span><span class="n">limit_extent</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.explore">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.explore">[docs]</a>
    <span class="k">def</span> <span class="nf">explore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gdf</span><span class="p">,</span>
        <span class="n">focal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
        <span class="n">edge_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">focal_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot graph as an interactive Folium Map</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gdf : geopandas.GeoDataFrame</span>
<span class="sd">            geodataframe used to instantiate to Graph</span>
<span class="sd">        focal : list, optional</span>
<span class="sd">            subset of focal observations to plot in the map, by default None.</span>
<span class="sd">            If none, all relationships are plotted</span>
<span class="sd">        nodes : bool, optional</span>
<span class="sd">            whether to display observations as nodes in the map, by default True</span>
<span class="sd">        color : str, optional</span>
<span class="sd">            color applied to nodes and edges, by default &quot;black&quot;</span>
<span class="sd">        edge_kws : dict, optional</span>
<span class="sd">            additional keyword arguments passed to geopandas explore function</span>
<span class="sd">            when plotting edges, by default None</span>
<span class="sd">        node_kws : dict, optional</span>
<span class="sd">            additional keyword arguments passed to geopandas explore function</span>
<span class="sd">            when plotting nodes, by default None</span>
<span class="sd">        focal_kws : dict, optional</span>
<span class="sd">            additional keyword arguments passed to geopandas explore function</span>
<span class="sd">            when plotting focal observations, by default None. Only applicable when</span>
<span class="sd">            passing a subset of nodes with the `focal` argument</span>
<span class="sd">        m : Folilum.Map, optional</span>
<span class="sd">            folium map objecto to plot on top of, by default None</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            additional keyword arguments are passed directly to geopandas.explore, when</span>
<span class="sd">            ``m=None`` by default None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        folium.Map</span>
<span class="sd">            folium map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_explore_graph</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">gdf</span><span class="p">,</span>
            <span class="n">focal</span><span class="o">=</span><span class="n">focal</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">edge_kws</span><span class="o">=</span><span class="n">edge_kws</span><span class="p">,</span>
            <span class="n">node_kws</span><span class="o">=</span><span class="n">node_kws</span><span class="p">,</span>
            <span class="n">focal_kws</span><span class="o">=</span><span class="n">focal_kws</span><span class="p">,</span>
            <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<span class="k">def</span> <span class="nf">_arrange_arrays</span><span class="p">(</span><span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rearrange input arrays so that observation indices</span>
<span class="sd">    are well-ordered with respect to the input ids. That is,</span>
<span class="sd">    an &quot;early&quot; identifier should always preceed a &quot;later&quot; identifier</span>
<span class="sd">    in the heads, but the tails should be sorted with respect</span>
<span class="sd">    to heads *first*, then sorted within the tails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">)))</span>
    <span class="n">lookup</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>
    <span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;focal&quot;</span><span class="p">:</span> <span class="n">heads</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">:</span> <span class="n">tails</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">weights</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">input_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">])</span>
        <span class="o">.</span><span class="n">assign</span><span class="p">(</span>
            <span class="n">focal_loc</span><span class="o">=</span><span class="n">input_df</span><span class="o">.</span><span class="n">focal</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">neighbor_loc</span><span class="o">=</span><span class="n">input_df</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;focal_loc&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor_loc&quot;</span><span class="p">])</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;focal_loc&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor_loc&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">read_parquet</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read Graph from a Apache Parquet</span>

<span class="sd">    Read Graph serialized using `Graph.to_parquet()` back into the `Graph` object.</span>
<span class="sd">    The Parquet file needs to contain adjacency table with a structure required</span>
<span class="sd">    by the `Graph` constructor and optional metadata with the type of transformation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str | pyarrow.NativeFile | file-like object</span>
<span class="sd">        path or any stream supported by pyarrow</span>
<span class="sd">    **kwargs</span>
<span class="sd">        additional keyword arguments passed to pyarrow.parquet.read_table</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Graph</span>
<span class="sd">        deserialized Graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adjacency</span><span class="p">,</span> <span class="n">transformation</span> <span class="o">=</span> <span class="n">_read_parquet</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adjacency</span><span class="p">,</span> <span class="n">transformation</span><span class="p">)</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018-, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.2.6.<br/>
    </p>
  </div>
</footer>
  </body>
</html>